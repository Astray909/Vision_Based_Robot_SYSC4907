//Motor Connections
//Change this if you wish to use another diagram
#define EnA 10
#define EnB 5
#define In1 9
#define In2 8
#define In3 7
#define In4 6

#define mov0 2
#define mov1 3
#define mov2 4
// #define mov3 11 //Ocuppied by sensor, dont use!

// #define debug1 3
// #define debug2 11 //Ocuppied by sensor, dont use!

// Sensor connection defined below. Uncomment when testing.
int sesM=11;
int sesL=12;
int sesR=13;

void setup() {
  // put your setup code here, to run once:
  // All motor control pins are outputs
  pinMode(EnA, OUTPUT);
  pinMode(EnB, OUTPUT);
  pinMode(In1, OUTPUT);
  pinMode(In2, OUTPUT);
  pinMode(In3, OUTPUT);
  pinMode(In4, OUTPUT);

  //000 == CASE0 == STOP
  //001 == CASE1 == STRAIGHT
  //010 == CASE2 == LEFT_Spin
  //011 == CASE3 == RIGHT_Spin
  //100 == CASE4 == LEFT_Curve
  //101 == CASE5 == RIGHT_Curve
  //110 == CASE6 == LEFTB     <= NOT USED
  //111 == CASE7 == RIGHTB    <= NOT USED
  //bit shifting as (mov2, mov1, mov0) in binary bits
  pinMode(mov0, INPUT);
  pinMode(mov1, INPUT);
  pinMode(mov2, INPUT);
  // pinMode(mov3, INPUT);   //Ocuppied by sensor, dont use!
  // pinMode(debug1, INPUT);
  // pinMode(debug2, INPUT); //Ocuppied by sensor, dont use!
  
  // sensor setup begings here: uncomment when testing
  pinMode(sesM, INPUT); // pin11 set as digital input from mid sensor
  pinMode(sesL, INPUT); // pin12 set as digital input from left sensor
  pinMode(sesR, INPUT); // pin13 set as digital input from right sensor
  
  Serial.begin(9600);
}

void loop() {
  // put your main code here, to run repeatedly:
  int cmdEn = 1; // Arduino only takes user commands when cmdEn = 1;
  
  // sensor reading bitshift sesR = (sesL, sesM, sesR)
  int sesR =(((digitalRead(sesL)<<2) | (digitalRead(sesM)<<1) | digitalRead(sesR))
  // 000 == CASE0 == collision detected in : NONE
  // 001 == CASE1 == collision detected in : right
  // 010 == CASE2 == collision detected in : mid
  // 011 == CASE3 == collision detected in : mid, right
  // 100 == CASE4 == collision detected in : left
  // 101 == CASE5 == collision detected in : left, right
  // 110 == CASE6 == collision detected in : left, mid
  // 111 == CASE7 == collision detected in : left, mid, right
  
  if (sesR == 2 || sesR == 3 || sesR == 6 || sesR == 7) // if middle sensor detect collision
  {
    cmdEn = 0;  //stop taking command and enter collision avoidance
    stop(); // First, robot stop check sensor stats
    if (sesR == 2 || sesR == 3) // if left sensor is clear,
      {
        while(sesR == 2 || sesR == 3) // while mid sensor still trigered
        {
           turnLeft(); // turn left
        }
        while(sesR == 1 || sesR == 4 || sesR == 5) // while obstacle on the front left/right
        {
           goStraight();   // goStraight avoid collision
        }
        //goStraight();
        if (sesR != 2 && sesR != 3 && sesR != 6 && sesR != 7) // if mid sensor cleared, no collision risk
        {
           goStraight();
           delay (1000);      // keep goStraight for 1sec
        }
        stop();     //stop for target reacquire
        cmdEn = 1;  //exit collision avoidance, resume taking order
      }
    else if (sesR ==  6) // if only right sensor is clear,
      {
        while(sesR ==  6) // while mid still blocked
         {
           turnRight(); // turn right
         }
         while(sesR == 1 || sesR == 4 || sesR == 5) // while obstacle on the front left/right
         {
           goStraight();   // goStraight avoid collision
         }
         //goStraight();
         if (sesR != 2 && sesR != 3 && sesR != 6 && sesR != 7) // if mid sensor cleared, no collision risk
         {
           goStraight();
           delay (1000);      // keep goStraight for 1sec
         }
         stop();     //stop for target reacquire
         cmdEn = 1;  //exit collision avoidance, resume taking order
      }
    else  // all sensors blocked
    {
      while(sesR == 7) // while mid sensor still trigered
       {
          turnLeft(); // turn left BY DEFAULT, as target tracking hovering is turn right
       }
       while(sesR == 1 || sesR == 4 || sesR == 5) // while obstacle on the front left/right
       {
          goStraight();   // goStraight avoid collision
       }
       //goStraight();
       if (sesR != 2 && sesR != 3 && sesR != 6 && sesR != 7) // if mid sensor cleared, no collision risk
       {
          goStraight();
          delay (1000);      // keep goStraight for 1sec
       }
       stop();     //stop for target reacquire
       cmdEn = 1;  //exit collision avoidance, resume taking order
    }
  }

  // motion control code from rpi to arduino below:               
  while (cmdEn == 1) // when cmdEn = 1, system takes user command
  {
    // Create command case variable cmdC using bit shifting:
    int cmdC =(((digitalRead(mov2)<<2) | (digitalRead(mov1)<<1) | digitalRead(mov0))
      // 000 == CASE0 == STOP
      // 001 == CASE1 == STRAIGHT
      // 010 == CASE2 == LEFT_Spin
      // 011 == CASE3 == RIGHT_Spin
      // 100 == CASE4 == LEFT_Curve
      // 101 == CASE5 == RIGHT_Curve
    switch(cmdC)
    {
      case0:
        Serial.println("cmdC == 0 == stop");
        stop();
        break;
      case 1:
        Serial.println("cmdC == 1 == goStraight");
        goStraight();
        break;
      case 2:
        Serial.println("cmdC == 2 == spinLeft");
        turnLeft();
        break;
      case 3:
        Serial.println("cmdC == 3 == spinRight");
        turnRight();
        break;
      case 4:
        Serial.println("cmdC == 4 == curveLeft");
        curveLeft();
        break;
      case 5:
        Serial.println("cmdC == 5 == curveRight");
        curveRight();
        break;
    }
    delay(10);    //delay 10ms between each read for stability
  }
}

void stop()
{
  analogWrite(EnA, 0);
  analogWrite(EnB, 0);
}

void goStraight()   //run both motors in the same direction
{
  analogWrite(EnA, 200);
  analogWrite(EnB, 200);
  // turn on motor A
  digitalWrite(In1, HIGH);
  digitalWrite(In2, LOW);
  // turn on motor B
  digitalWrite(In3, LOW);
  digitalWrite(In4, HIGH);
}

void goBack()   //run both motors in the same direction
{
  analogWrite(EnA, 200);
  analogWrite(EnB, 200);
  // turn on motor A
  digitalWrite(In1, LOW);
  digitalWrite(In2, HIGH);
  // turn on motor B
  digitalWrite(In3, HIGH);
  digitalWrite(In4, LOW);
}

void turnLeft()
{
  analogWrite(EnA, 100);
  analogWrite(EnB, 100);
  // turn on motor A
  digitalWrite(In1, HIGH);
  digitalWrite(In2, LOW);
  // turn on motor B
  digitalWrite(In3, HIGH);
  digitalWrite(In4, LOW);
}

void turnRight()
{
  analogWrite(EnA, 100);
  analogWrite(EnB, 100);
  // turn on motor A
  digitalWrite(In1, LOW);
  digitalWrite(In2, HIGH);
  // turn on motor B
  digitalWrite(In3, LOW);
  digitalWrite(In4, HIGH);
}

void curveLeft()   //run both motors in the same direction
{
  analogWrite(EnA, 200);
  analogWrite(EnB, 100);
  // turn on motor A
  digitalWrite(In1, HIGH);
  digitalWrite(In2, LOW);
  // turn on motor B
  digitalWrite(In3, LOW);
  digitalWrite(In4, HIGH);
}

void curveRight()   //run both motors in the same direction
{
  analogWrite(EnA, 100);
  analogWrite(EnB, 200);
  // turn on motor A
  digitalWrite(In1, HIGH);
  digitalWrite(In2, LOW);
  // turn on motor B
  digitalWrite(In3, LOW);
  digitalWrite(In4, HIGH);
}

void backLeft()   //run both motors in the same direction
{
  analogWrite(EnA, 200);
  analogWrite(EnB, 100);
  // turn on motor A
  digitalWrite(In1, LOW);
  digitalWrite(In2, HIGH);
  // turn on motor B
  digitalWrite(In3, HIGH);
  digitalWrite(In4, LOW);
}

void backRight()   //run both motors in the same direction
{
  analogWrite(EnA, 100);
  analogWrite(EnB, 200);
  // turn on motor A
  digitalWrite(In1, LOW);
  digitalWrite(In2, HIGH);
  // turn on motor B
  digitalWrite(In3, HIGH);
  digitalWrite(In4, LOW);
}
